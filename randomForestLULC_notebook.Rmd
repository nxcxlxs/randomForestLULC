---
title: "Classificação LULC via Random Forest"
output: html_notebook
---
```{r}
#carregar bibliotecas necessárias.
library(raster)
library(sf)
library(randomForest)
```
```{r}
#local onde foram baixados os arquivos disponibilizados na pasta 'data'.
pathToFiles <- "C:/Users/Nicolas/VC"
```
```{r}
#processar bandas.
products <- list.files(pathToFiles, full.names = TRUE)

bands <- c(grep('B1', products, value=TRUE),
           grep('B2', products, value=TRUE),
           grep('B3', products, value=TRUE),
           grep('B4', products, value=TRUE),
           grep('B5', products, value=TRUE),
           grep('B6', products, value=TRUE),
           grep('B7', products, value=TRUE)) 
```
```{r}
img <- stack(bands) #fundir as bandas.

shp <- read_sf("training_dataREPROJ.shp") #carregar os vetores de amostragem.

shp <- shp[c(-425),] #um polígono ficou vazio.

compareCRS(img,shp) #mesmo SRC em ambos.
```
```{r}
#visualização.
plotRGB(img, r = 4, g = 3, b = 2, stretch = "lin", colNA = 'white')
plot(shp, col="red", add=TRUE) 
```
```{r}
#conversão de classes em caracteres.
levels(as.factor(shp$class))

for (i in 1:length(unique(shp$class)))
  {cat(paste0(i, " ", levels(as.factor(shp$class))[i]), sep="\n")}
```
```{r}
#renomear as bandas. melhora a visualização de mean decrease Accuracy e Gini.
names(img)
names(img) <- c("b1", "b2", "b3", "b4", "b5", "b6", "b7")
names(img)
```
```{r}
#extração de valores de reflectância.
start.timeXtr <- Sys.time()
smp <- raster::extract(img, shp, df = TRUE)
end.timeXtr <- Sys.time()
time.takenXtr <- round(end.timeXtr - start.timeXtr,2)
```
```{r}
time.takenXtr #tempo necessário para extração.
```
```{r}
#combinar coluna 'ID' da extração com a coluna 'class' dos vetores.
smp$cl <- as.factor(shp$class[match(smp$ID, seq(nrow(shp)))])
smp <- smp[-1] #remover a coluna ID
```
```{r}
smp
```
```{r}
#salvar o dataframe da amostragem.
save(smp, file = "smp.rda")

load(file = "smp.rda")
```

```{r}
#salvar o dataframe da amostragem.
save(smp, file = "smp.rda")

load(file = "smp.rda")
```
```{r}
#visualização dos perfis espectrais das classes.
sp <- aggregate( . ~ cl, data = smp, FUN = mean, na.rm = TRUE )
graphics::plot(0,
     ylim = c(min(sp[2:ncol(sp)]), max(sp[2:ncol(sp)])), 
     xlim = c(1, ncol(smp)-1),
     type = 'n', 
     xlab = "Bandas Landsat", 
     ylab = "Reflectância [% * 100]")

mycolors <- c("#E974ED", "#af2a2a", "#0000FF",
              "#006400", "#FFEFC3", "#FFD966", "#935132")

for (i in 1:nrow(sp)){
  lines(as.numeric(sp[i, -1]), 
        lwd = 4, 
        col = mycolors[i]
  )
}

grid(col = "black")

legend(as.character(sp$cl),
       x = "topleft",
       col = mycolors,
       lwd = 5,
       bty = "n")
```

```{r}
#visualização dos perfis espectrais das classes.
sp <- aggregate( . ~ cl, data = smp, FUN = mean, na.rm = TRUE )
graphics::plot(0,
     ylim = c(min(sp[2:ncol(sp)]), max(sp[2:ncol(sp)])), 
     xlim = c(1, ncol(smp)-1),
     type = 'n', 
     xlab = "Bandas Landsat", 
     ylab = "Reflectância [% * 100]")

mycolors <- c("#E974ED", "#af2a2a", "#0000FF",
              "#006400", "#FFEFC3", "#FFD966", "#935132")

for (i in 1:nrow(sp)){
  lines(as.numeric(sp[i, -1]), 
        lwd = 4, 
        col = mycolors[i]
  )
}

grid(col = "black")

legend(as.character(sp$cl),
       x = "topleft",
       col = mycolors,
       lwd = 5,
       bty = "n")
```
```{r}
#avaliação da distribuição das amostras nas classes.
summary(smp$cl)
```
```{r}
#sub-dimensionamento da amostra a partir da classe minoritária.
smp.size <- rep(min(summary(smp$cl)), nlevels(smp$cl))
smp.size
```
```{r}
#modelagem.
rfmodel <- tuneRF(x = smp[-ncol(smp)],
                  y = smp$cl,
                  sampsize = smp.size,
                  strata = smp$cl,
                  ntree = 250,
                  importance = TRUE,
                  doBest = TRUE,                  #whether to run a forest using the optimal mtry found
                  plot = TRUE                     #whether to plot the OOB error as function of mtry
)
```
```{r}
#info do modelo.
rfmodel
```
```{r}
#importância das variáveis.
varImpPlot(rfmodel)
```

```{r}
#importância das variáveis.
varImpPlot(rfmodel)
```
```{r}
#plot do modelo.
plot(rfmodel, col = c("#000000", "#E974ED", "#af2a2a", "#0000FF",
                      "#006400", "#FFEFC3", "#FFD966", "#935132"), lwd = 3)
```
```{r}
#plot do modelo.
plot(rfmodel, col = c("#000000", "#E974ED", "#af2a2a", "#0000FF",
                      "#006400", "#FFEFC3", "#FFD966", "#935132"), lwd = 3)
```
```{r}
#salvar modelo.
save(rfmodel, file = "rfmodel.RData")

load("rfmodel.RData")
```
```{r}
#salvar modelo.
save(rfmodel, file = "rfmodel.RData")

load("rfmodel.RData")
```
```{r}
#rodar classificação.
start.timeClass <- Sys.time()
result <- raster::predict(img,
                          rfmodel,
                          filename = "RF_classification.tif",
                          overwrite = TRUE,
                          progress = "text")
end.timeClass <- Sys.time()
time.takenClass <- round(end.timeClass - start.timeClass, 2)

time.takenClass #tempo necessário para classificação.
```
```{r}
#rodar classificação.
start.timeClass <- Sys.time()
result <- raster::predict(img,
                          rfmodel,
                          filename = "RF_classification.tif",
                          overwrite = TRUE,
                          progress = "text")
end.timeClass <- Sys.time()
time.takenClass <- round(end.timeClass - start.timeClass, 2)
```

```{r}
time.takenClass #tempo necessário para classificação.
```
```{r}
#plotar classificação.
plot(result, 
     axes = FALSE, 
     box = FALSE,
     col = mycolors)
```

```{r}
#plotar classificação.
plot(result, 
     axes = FALSE, 
     box = FALSE,
     col = mycolors)
```
```{r}
for (i in 1:length(unique(shp$class)))
  {cat(paste0(i, " ", levels(as.factor(shp$class))[i]), sep="\n")}
```


